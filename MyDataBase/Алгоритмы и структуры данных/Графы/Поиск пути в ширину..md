Сложность O(V + E) Где V - Кол-во ребер, а E - Кол-во элементов.

Данный алгоритм строится на очереди, которая работает по принципу, первый вошел - первый вышел. Проверка идет до тех пор, пока в очереди есть элементы, если в очереди закончились элементы то значит путь не удалось найти. 
Изначально в очереди только один элемент, это стартовый элемент с которого мы начинаем поиск, поскольку граф имеет информацию о своих соседях, то мы можем проверить текущий элемент на наличие того элемента, который мы ищем, к примеру у нас имеется следующая структура графов.
![[Graph.png]]
Мы начинаем свой путь с графа под номером 1, а ищем граф под номером 3, первым делом проверяем соседей графа 1:
Граф 1 имеет соседей с номерами: (5, 6, 3, 2, 4):
Сосед 5 не является соседом с номером 3, но у него есть сосед с номером 8, а значит его нужно добавить в список для проверки, а сам элемент под номером 5 нам больше не нужен, мы можем удалить его и заблокировать, что-бы не учитывать в следующих проверках, теперь у нас получается следующая очередь:
(6, 3, 2, 4, 8), элемент с номером 8 встал в конец очереди и будет проверен самым последним.
Проверяем элемент под номером 6, он тоже не является элементом с номером 3, но у него есть сосед с номером 7, добавим его в очередь.
(3, 2, 4, 8, 7), опять встал последним, а 6ку удалили, что-бы больше не проверять. 
Теперь проверяем 3, она нам и нужна, а значит мы нашли путь.
Таким образом проверив всех соседей мы найдем граф под номером 3, а значит поиск завершиться, мы быстро нашли нужный нам элемент!
Усложним задачу, теперь нам надо найти граф под номером 11, мы уже сделали проверки для 5, 6 и 3, и все они не являются 11, поскольку 3ка не имеет соседей, мы не добавляем в нашу очередь ничего нового, а лишь удаляем 3ку, получаем:
(2, 4, 8, 7)
2 тоже не 11, и тоже не имеет соседей, удаляем ее.
(4, 8, 7)
4 не 11, соседей нет, удаляем
(8, 7)
Теперь мы видим что остались только соседи соседей, именно поэтому это поиск в ширину, он делит наш граф на слои, где на первом слое находится ближние соседи, на втором соседи соседей и тд

Суть алгоритма в следующем, у нас имеется стартовая и конечная точка, поскольку в элементе графа есть информация о том, кто является соседом этого графа, мы можем проверить всех соседей, и если среди соседей графа есть тот что нам нужен, вернуть путь до него, а если нет, то взять элемент который мы проверяли, и добавить в конец очеред
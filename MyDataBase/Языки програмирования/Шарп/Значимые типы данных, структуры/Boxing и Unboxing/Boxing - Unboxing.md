Как мы помним, значимые хранятся в стеке, а ссылочные в управляемой куче, так вот, операциями Boxing-а и Unboxing-а называют перемещение данных, находящихся на стеке в управляемую кучу, что плохо сказывается на производительности проекта. 
Зачем нам перемещать эти данные? Мы делаем это не специально, пользуясь приведением типов, а именно, когда мы преобразовываем значимый тип (структуру) в ссылочный тип (класс) сделать мы это можем через [[Приведение простых типов]] или используя такие структуры как  [[ArrayList]].

```csharp
using System.Collections;
using EntryPoint;

namespace HomeworksStudent._00Lessons.StackAndHeap.BoxingUnboxing {
    internal class BoxingUnboxingStarter : IEntryPoint {
        public void Start() {
            int value = 123;
            object boxingValue = value;
            //В этот момент у нас создался объект в управляемой куче, под него выделилась память
            int unboxingValue = (int)boxingValue;
            //В этот момент мы получили объект из управляемой кучи по ссылке, и создали на его основе структуру типа int
        }

        public void StructExample() {
            int value = 123;
            object boxingValue = value;
            //В этот момент у нас создался объект в управляемой куче, под него выделилась память
            int unboxingValue = (int)boxingValue;
            //В этот момент мы получили объект из управляемой кучи по ссылке, и создали на его основе структуру типа int
        }

        public void ArrayListExample() {
            ArrayList arrayList = new ArrayList();
            arrayList.Add(123);
            //Добавив наше число в ArrayList - мы его упокавали, так как ArrayList - принимает в себя объекты типа object
        }
    }
}
```
Стоит понимать что операция упаковки, намного затратнее по ресурсам чем операция распаковки так как в первом случае всегда будет выделяться дополнительная память, но за распаковкой всегда следует копирование полей из упакованого типа.
Для того что-бы следить за тем, где и как у нас упаковываются наши типы, мы можем использовать расширение Il.spy для visual studio, которое позволяет исследовать IL код, который генерируется на наш c# код.
На il коде, операция распаковки выглядит как box (тип который вы упоковали), а распаковки Unbox.any (Тип в который мы хотим распоковать)
Если же без упаковки никак не обойтись, то лучше делать это самостоятельно, так будет более наглядно и не получится следующих проблем

```csharp
        public sealed class Program {
            public static void Main() {
                Int32 v = 5;
                //Упаковываем 3 раза
                Console.WriteLine("{0}, {1}, {2}", v, v, v);
                //Упаковываем 1 раз и используем дальше
                Object o = v;
                Console.WriteLine("{0}, {1}, {2}", o, o, o);
            }
        }
```

Плюс ко всему, поймать упаковку можно в момент переопределения таких методов как:
ToString(), GetHashCode(), Equals().
Если в момент переопределения этих методов оставить обращение к base:, если этого обращения нет, то упаковка не происходит. НО, вызов такого метода как:
GetType() - ВСЕГДА ВЫЗЫВАЕТ УПАКОВКУ ЗНАЧИМОГО ОБЪЕКТА, так как требует указатель на объект в куче.

Кроме того, структура всегда запакуется, если ее привести к интерфейсу:
```csharp
        public interface TestInterface {
            public void Test();
        }

        public void InterfaceTest() {
            Point poin = new Point();
            TestInterface testInterface = poin;
        }
```

[[Когда структура будет упакована|Итог, упаковку можно поймать в случаях]]
[[Изменение упакованной структуры в управляемой кучи, без распаковки.]]

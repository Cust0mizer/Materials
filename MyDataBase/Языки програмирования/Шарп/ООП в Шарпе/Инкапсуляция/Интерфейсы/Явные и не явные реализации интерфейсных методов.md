Интересный факт, представим что у нас есть все та-же реализация примера интерфейса из [[Интерфейсы, База. Зачем нужны, как использовать|базового описания]]
Но немного его модифицируем, объявим переменную инициализирующего класса и вызовем ее

```csharp
using EntryPoint;

namespace HomeworksStudent._00Lessons.Interface {
    public class InterfaceEntryPoint : IEntryPoint {
        public void Start() {

        }

        public void CallInterfaceAndClassMethod() {
            InitializeClass initializeClass = new InitializeClass();
            //Вызывается метод класса
            initializeClass.Initialize();

            //Вызывается метод интерфейса
            IInitializeInterfaceExample initializeInterface = initializeClass;
            initializeInterface.Initialize();
        }
    }

    public interface IInitializeInterfaceExample {
        public void Initialize();
    }

    public class InitializeClass : IInitializeInterfaceExample {
        public void Initialize() {
        }
    }
}
```
Как мы видим, метод вызывается в одном случае именно у класса, а в другом именно у интерфейса.
А теперь вспоминаем что у каждого ссылочного объекта есть синхронизатор, и объект типа, которые дополнительно создаются. Так вот, в объекте типа, объекта который реализует интерфейс есть дополнительные методы, именно от интерфейса, и дополнительно метод который прописан в самом классе, грубо говоря, метод `Initialize` занесен туда 2 раза. Отсюда у нас есть возможность вызывать метод как у интерфейса, так и у объекта класса, а дополнительно еще и задавать не явную реализацию - это то, что было изначально, когда мы не пишем что метод принадлежит интерфейсу, и явную:

```csharp
    public class InitializeClass : IInitializeInterfaceExample {
        void IInitializeInterfaceExample.Initialize() {
        }

        public void Initialize() {
        }
    }
```
В таком случае, у нас есть только один способ обратиться к интерфейсному методу, и это через объект интерфейса.
N
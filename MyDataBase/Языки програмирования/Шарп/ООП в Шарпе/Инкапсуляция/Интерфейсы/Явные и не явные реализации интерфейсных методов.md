Интересный факт, представим что у нас есть все та-же реализация примера интерфейса из [[Интерфейсы, База. Зачем нужны, как использовать|базового описания]]
Но немного его модифицируем, объявим переменную инициализирующего класса и вызовем ее

```csharp
using EntryPoint;

namespace HomeworksStudent._00Lessons.Interface {
    public class InterfaceEntryPoint : IEntryPoint {
        public void Start() {

        }

        public void CallInterfaceAndClassMethod() {
            InitializeClass initializeClass = new InitializeClass();
            //Вызывается метод класса
            initializeClass.Initialize();

            //Вызывается метод интерфейса
            IInitializeInterfaceExample initializeInterface = initializeClass;
            initializeInterface.Initialize();
        }
    }

    public interface IInitializeInterfaceExample {
        public void Initialize();
    }

    public class InitializeClass : IInitializeInterfaceExample {
        public void Initialize() {
        }
    }
}
```
Как мы видим, метод вызывается в одном случае именно у класса, а в другом именно у интерфейса.

А теперь вспоминаем что у каждого ссылочного объекта есть синхронизатор, и объект типа, которые дополнительно создаются. Так вот, в объекте типа, объекта который реализует интерфейс есть дополнительные методы, именно от интерфейса, и дополнительно метод который прописан в самом классе, грубо говоря, метод `Initialize` занесен туда 2 раза. Отсюда у нас есть возможность вызывать метод как у интерфейса, так и у объекта класса, а дополнительно еще и задавать не явную реализацию - это то, что было изначально, когда мы не пишем что метод принадлежит интерфейсу, и явную:

```csharp
    public class InitializeClass : IInitializeInterfaceExample {
        void IInitializeInterfaceExample.Initialize() {
        }

        public void Initialize() {
        }
    }
```
В таком случае, у нас есть только один способ обратиться к интерфейсному методу, и это через объект интерфейса.
Тоже самое, если у нас есть 2 интерфейса, и в них совпадают имена методов, в таком случае нам придется исопльзовать явную реализацию интерфейса.

Использовать это можно для избежания упаковки, в тех случаях когда нет обобщенной версии интерфесов и приходиться использовать не обобщенную. 
Как пример можно рассмотреть интерфейс `IComparable` - хотя у него и есть обобщенная версия, рассмотрим на примере с необобщенной:

```csharp
internal struct SomeValueType : IComparable { private Int32 m_x;

public SomeValueType(Int32 x) { 
	m_x = x; 
}

public Int32 CompareTo(SomeValueType other) { 
	return(m_x _ other.m_x);
}

// ПРИМЕЧАНИЕ: в следующей строке не используется public/private

	Int32 IComparable.CompareTo(Object other) { 
		return CompareTo((SomeValueType) other);
	} 
}
```
В это случае при обращении через тип `SomeValueType` упаковка не будет выполняться, по факту метод с object - будет использоваться только в том случае, когда мы будем вызывать его на интерфейсе.

Но и тут не без проблем, к очевидным можно отнести то, что методы будут банально не доступны из типа данных, и всегда придется преобразовывать тип данных к интерфейсному типу, что приводит к упаковке, а так-же эти методы не будут доступны в классах наследниках.
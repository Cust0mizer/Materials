Стек и куча и то и другое – это область оперативной памяти.

Для стека выделяется маленький объем памяти, а для кучи большой.

Стек до 1мб.

Стек используется для хранения переменных, для вызова методов и для выполнения операций над переменными.

Стек является динамической структурой данных и работает по системе LIFO – Last in First Out – Последний вошёл, первый вышел, можно представить как стакан, в который мы складываем шарики, и последний шарик всегда будет вверху и пока мы его не достанем, не сможем добраться до шариков ниже.

В стеке проще размещать данные и чистить его при необходимости.
![[Pasted image 20240620214654.png]]
Мы не сможем добраться до шаров ниже, до тех пор, пока не вытащим  верхние.

|           Что нужно знать?            |                            Значимые типы.                             |             Ссылочные типы.              |
|:-------------------------------------:|:---------------------------------------------------------------------:|:----------------------------------------:|
|            Где размещаются            |                                В стеке                                |                  В куче                  |
|             Как отличить              | Структуры, Enum, простые переменные, к примеру Int, float, bool, char |              Class, string               |
|     Когда перестают существовать?     |           Когда покидают контекст, в котором унаследованы.            | Когда объект подвергается сборке мусора. |
| Поведение при передаче и копировании. |        ==Передаются по значению, копируются реальные данные.==        |          ==Копируется ссылка.==          |
[[Пример копирования по ссылке и передачи по значению|Что значит передается по значению и ссылке?]]

Есть 3 вида кучи, SOH, LOH, POH,
1 –  Small object heap - Для маленьких объектов до 85кб,
2 – Large object heap - Для больших, более 85кб также в LOH не происходит дефрагментация памяти поэтому все большие файлы сразу попадают в сборщик мусора 3го уровня.
3 – Pineted object Heap - Добавилась совсем не давно с DotNet 5. Специальная куча для закреплённый объектов.

Размер кучи задается при запуске приложения и в отличии от кучи он ограничен лишь физически.

Все структуры являются потомками от System.ValueType, который в свою очередь потомок System.Object
А все перечесление потомки System.Enum который потомок System.ValueType

[[Сборщик мусора Garbage Collector]]
[[Стек как динамическая коллекция в шарпе]]
[[Ключевое слово Ref]]
[[Ключевое слово Out]]
[[Ключевое слово In]]



Как CLR управляет размещением полей для типа

Для повышения производительности CLR дано право устанавливать порядок размещения полей типа. Например, CLR может выстроить поля таким образом, что ссылки на объекты окажутся в одной группе, а поля данных и свойства — выровненные и упакованные — в другой. Однако при описании типа можно указать, сохранить ли порядок полей данного типа, определенный программистом, или разрешить CLR выполнить эту работу.

Для того чтобы сообщить CLR способ управления полями, укажите в описании класса или структуры атрибут System.Runtime.InteropServices.StructLayoutAttribute. Чтобы порядок полей устанавливался CLR, нужно передать конструктору атрибута параметр LayoutKind.Auto, чтобы сохранить установленный программистом порядок — параметр LayoutKind.Sequential, а параметр LayoutKind. Explicit позволяет разместить поля в памяти, явно задав смещения. Если в описании типа не применен атрибут StructLayoutAttribute, порядок полей выберет компилятор.

Для ссылочных типов (классов) компилятор C# выбирает вариант LayoutKind. Auto, а для значимых типов (структур) — LayoutKind.Sequential. Очевидно, разработчики компилятора считают, что структуры обычно используются для взаимодействия с неуправляемым кодом, а значит, поля нужно расположить так, как определено разработчиком. Однако при создании значимого типа, не работающего совместно с неуправляемым кодом, скорее всего, поведение компилятора, предлагаемое по умолчанию, потребуется изменить, например:

using System;

using System.Runtime.InteropServices;

// Для повышения производительности разрешим CLR // установить порядок полей для этого типа [StructLayout(LayoutKind.Auto)]

internal struct SomeValType { private readonly Byte m_b;

продолжение 

156 Глава 5 . Примитивные, ссылочные и значимые типы

private readonly Int16 m_x; ...

}

Атрибут StructLayoutAttribute также позволяет явно задать смещение для всех полей, передав в конструктор LayoutKind.Explicit. Затем можно применить атрибут System.Runtime.InteropServices.FieldOffsetAttribute ко всем полям путем передачи конструктору этого атрибута значения типа Int32, определяющего смещение (в байтах) первого байта поля от начала экземпляра. Явное размещение обычно используется для имитации того, что в неуправляемом коде на C/C++ называлось объединением (union), то есть размещения нескольких полей с одного смещения в памяти, например:

using System;

using System.Runtime.InteropServices;

// Разработчик явно задает порядок полей в значимом типе [StructLayout(LayoutKind.Explicit)]

internal struct SomeValType { [FieldOffset(0)]

private readonly Byte m_b; // Поля m_b и m_x перекрываются

[FieldOffset(0)]

private readonly Int16 m_x; // в экземплярах этого класса }

Не допускается определение типа, в котором перекрываются ссылочный и значимый типы. Можно определить тип, в котором перекрываются несколько значимых типов, однако все перекрывающиеся байты должны быть доступны через открытые поля, чтобы обеспечить верификацию типа
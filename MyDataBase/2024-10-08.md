> Asset bundles - это zip архив в нашем проекте, который мы можем запаковать, папка Resources, тоже в своем роде Asset Bundles

> Мы можем поменять расширение нашего билда с Apk или Ipa, на Zip, дальше открыв билд, можно посмотреть из каких файлов состоит наш билд.

> Плюсы Addressable
> Удобное API, с возможностью асинхронной загрузки
> Скорость загрузки увеличивается
> Можно разбить бандлы на те что будут храниться на сервере и те что будут хранится локально
> Легко выгружать из памяти
> Use Case:
> 1) Обход лимита в сторе, 
> 2) Оптимизация памяти (Пример с не используемым меню)
> 

В Addressable - можно поместить все кроме скриптов.
Для добавление элемента в Addressable - нужно поставить галочку 
![[Pasted image 20241008134412.png]]
Если мы хотим поместить туда все файлы находящиеся в папке, то нужно поставить эту галочку на папке, но тут стоит понимать что если все в файлы в папке с галочкой и сама папка с галочкой, то в Addressable, будут продублированы все файлы в папке и сама папка. 
Если мы хотим что-бы все файлы из папки собирались как отдельные бандлы, к примеру у нас есть 100 уровней, каждый из уровней весит по 5мб, и мы не хотим грузить их все сразу, а лишь постепенно, то необходимо наоборот снять галочку с Addressable, на папке, поставить галочку на каждом файле, а в настройках группы выбрать: Pack Separately
![[Pasted image 20241008162330.png]]

Если мы закидываем в Addressable, к примеру SO, в котором есть ссылки на спрайты, то Addressable, автоматически добавит эти спрайты в AssetBundle.
Так-же стоит понимать что он может 2 раза добавить их в AssetBundle, если на наш спрайт ссылаются с 2х разных мест, примеру с Prefab и SO и оба этих объекта добавлены в AssetBundle.


Как происходит загрузка новых бандлов?
Первым делом загружается файл Catalog.Json, если этого файла вообще нет, то бандлы грузятся с сервера, если этот файл есть, то идет проверка, в этом файле для каждого бандла есть версия, если на сервере будет версия более высокая чем у нас, то мы загрузим новую версию себе локально. (Это добавить про рассказ о том, что бандлы не удаляются)

Анализ Asset Bundles
Бандлы лежат по пути
ПапкаПроекта\Library\com.unity.addressables\aa\название платформы для которой собирались бандлы\название платформы для которой собирались бандлы
С помощью программы Asset Studio Gui, можно открыть собранные бандлы, и посмотреть что в них попало, оценить вес который занимают эти бандлы. Так-же можно смотреть и чужие бандлы.

Рассказ про обновление версии бандлов на 1.50

Разбивка бандлов:
Логично разбивать по смысловым группам:
1) Префабы
2) Спрайты
3) Звуки
Разбивка по частоте использования, те что используются чаще выносятся в отдельные бандлы. Но тут важно держать баланс, не сводить все к отдельного бандла к отдельному файлу.
Когда разбивать? Смотрим на загрузку уровня, загрузку того что мы загружаем, и если это долго, то разбиваем.

Загрузка префабов.
Есть 2 варианта, просто загрузить префаб и получить его, для дальнейшего использования или сразу загрузить и создать.
Первый вариант:

```csharp
        public async UniTask<AssetLoadResult<T>> LoadPrefab<T>(string path) {
            AsyncOperationHandle<T> asyncOperationHandle = Addressables.LoadAssetAsync<T>(path);
            T result = await asyncOperationHandle;
            AssetLoadResult<T> assetLoadResult = new AssetLoadResult<T>(result, asyncOperationHandle);
            return assetLoadResult;
        }
```

Второй вариант:
```csharp
        public async UniTask<T> InstancePrefab<T>(string path, Transform parent, Vector3 position, Quaternion rotation) where T : MonoBehaviour {
            InstantiationParameters parameters = new InstantiationParameters(position, rotation, parent);
            T result = await Addressables.InstantiateAsync(path, parameters).Task as T;
            return result;
        }
    //НЕ ТЕСТИЛ!
```


Анализ зависимостей, избавление от дубликатов.
В этом нам поможет вкладка: 
Analyze
![[Pasted image 20241008174355.png]]
![[Pasted image 20241008174431.png]]
Там есть несколько созданных правил изначально, одно из них
![[Pasted image 20241008174454.png]]
И анализирует зависимости, так-же можно писать правила самому.
После анализа получил то, что у меня дублируется шейдер
![[Pasted image 20241008174602.png]]Там-же можно запросить фикс зависимостей.
Fix Selected Rules
![[Pasted image 20241008174926.png]]


Явный запуск инициализации Addressable:
Для этого можем использовать строчку:

```csharp
            await Addressables.InitializeAsync().Task;

```
Которая запустит инициализацию.

Загрузку можно производить не только по пути до файла, но и по Labels.
![[Pasted image 20241008180014.png]]
К примеру тут Labels установлен как preload, и если во время загрузки ассета, мы вместо пути укажем "Preload", то загрузится все то, что мы указали этим лейблом.
Или к примеру такой строкой мы можем сделать предзагрузку нескольких ассетов по лейблу
```csharp
            await Addressables.DownloadDependenciesAsync("Preload").Task;
```

Использование AssetReference
Представим ситуацию когда мы хотим создавать какой-то объект внутри другого объекта, ну к примере в главном меню у нас есть меню паузы, как часто игрок будет на него нажимать? Думаю не очень, но в тоже время там может быть достаточно большое кол-во картинок, что так-же загрузит оперативную память. Что делать? Можно конечно загружать нужное меню через подход который был разобран раньше (вставить ссылку на то, как грузить), а можно воспользоваться Asset Reference, по факту это очень похоже на установку обычного сериализовоного объекта в юнити инспекторе, пример:

```csharp
    public class MenuManager : MonoBehaviour {
        [SerializeField] private AssetReference mainLayoutPrefab;
        [SerializeField] private AssetReference itemsLayoutPrefab;
        [SerializeField] private Transform parent;
        private MainLayout mainLayout;
        private ItemsLayout itemsLayout;

        private void Start() {
            OpenMainLayout();
        }

        private void OnDisable() {
            mainLayout.openItems -= OpenItemsLayout;

            if (null != itemsLayout) {
                itemsLayout.Close -= OpenMainLayout;
            }
        }

        private async void OpenItemsLayout() {
            if (null == itemsLayout) {
                var goPrefab = await Addressables.InstantiateAsync(itemsLayoutPrefab, parent).Task;

                itemsLayout = goPrefab.GetComponent<ItemsLayout>();
                itemsLayout.Close += OpenMainLayout;
            }

            itemsLayout.gameObject.SetActive(true);
            mainLayout.gameObject.SetActive(false);
        }

        private async void OpenMainLayout() {
            if (null == mainLayout) {
                var goPrefab = await Addressables.InstantiateAsync(mainLayoutPrefab, parent).Task;

                mainLayout = goPrefab.GetComponent<MainLayout>();
                mainLayout.openItems += OpenItemsLayout;
            }

            mainLayout.gameObject.SetActive(true);

            if (null != itemsLayout) {
                itemsLayout.gameObject.SetActive(false);
            }
        }
    }
```
Тут при с
Название среды — общеязыковая среда выполнения (Common Language Runtime, CLR) — говорит само за себя: это среда выполнения, которая подходит для разных языков программирования. Основные возможности CLR (управление памятью, загрузка сборок, безопасность, обработка исключений, синхронизация) доступны в любых языках программирования, использующих эту среду.

Компиляторы машинного кода производят код, ориентированный на конкретную процессорную архитектуру, например x86, х64 или ARM. В отличие от этого, все CLR-совместимые компиляторы генерируют IL-код. (Подробнее об IL-коде рассказано далее в этой главе.) IL-код иногда называют управляемым (managed code), потому что CLR управляет его выполнением.


Что происходит при вызове оператора New?
1. Вычисление количества байтов, необходимых для хранения всех экземплярных полей типа и всех его базовых типов, включая System.Object (в котором отсутствуют собственные экземплярные поля). ==Кроме того, в каждом объекте кучи должны присутствовать дополнительные члены, называемые указателем на объект-тип (type object pointer) и индексом блока синхронизации (sync block index); они необходимы CLR для управления объектом. Байты этих дополнительных членов добавляются к байтам, необходимым для размещения самого объекта.==
2. Выделение памяти для объекта с резервированием необходимого для данного типа количества байтов в управляемой куче. Выделенные байты инициализируются нулями (0).
3. Инициализация указателя на объект-тип и индекса блока синхронизации.
4. Вызов конструктора экземпляра типа с параметрами, указанными при вызове new (в предыдущем примере это строка ConstructorParam1). Большинство компиляторов автоматически включает в конструктор код вызова конструктора базового класса. Каждый конструктор выполняет инициализацию определенных в соответствующем типе полей. В частности, вызывается конструктор System. Object, но он ничего не делает и просто возвращает управление.

Как создается класс? И как объекты понимают где и какие методы есть?
При создании объекта, помимо создания всех его полей, создаются еще 2 дополнительных объекта
1) Указатель на объект тип.
2) Индекс блока синхронизации.
Они необходимы для управления объектом.
Как раз в объекте типа, на который содержится указатель, есть таблица методов со всеми входными точками этих методов для этого типа данных. 
К примеру у нас есть класс:

```csharp
public class Human {
    public void Walk() {

    }

    public virtual void Run() {

    }
}
```
То в таблицу такого класса поместиться 2 метода, с их входными точками.
Если же у нас есть класс
```csharp
public class Student : Human {
    public override void Run() {
        base.Run();
    }
}
```
То в его таблицу будет добавлен только 1 метод, Run, так как он особенный именно для него не смотря на то, что он просто вызывает базовый метод.
Создавая объект-тип, среда CLR должна его как-то инициализировать. Резонно спросить: «Какие значения будут присвоены при инициализации?» В общем, при своем запуске в процессе CLR сразу же создает специальный объект-тип для типа System.Type (он определен в MSCorLib dll). Объекты типа Human и Student являются «экземплярами» этого типа, и по этой причине их указатели на объекты-типы инициализируются ссылкой на объект-тип.
Конечно, объект-тип System.Type сам является объектом и поэтому также содержит указатель на объект-тип; значит, закономерно поинтересоваться, на что ссылается этот указатель. А ссылается он на самого себя, так как объект-тип System. Type сам по себе является «экземпляром» объекта-типа
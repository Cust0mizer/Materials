> ==Space(10)== – Нацелен на поля, помогает разделять поля в инспекторе между собой, число – высота отступа.

> Header(“Name”) – Добавляет небольшой отступ, а главное, задает имя в инспекторе.

> HideInInspector – Убирает отображение поля из инспектора.

> NonSerialized – Убирает сериализацию у публичных полей, пропадет отображение поле из инспектора как в случае HideInInspector.

> Serializable – Применяется к классам или структурам, теперь целая структура или класс будет отображаться в инспекторе.

> FormerlySerializedAs(“OldName”) – Указав старое имя, мы избежим той ситуации, когда при переименовании поля, у нас слетают все ссылки

> Tooltip(“Подсказка”) – Позволит добавить подсказки для полей, которые будут отображаться в инспекторе при наведении на поле.

> ==InspectorName(“Name”)== – Применяется только для Enum, позволит применять в коде более короткие названия, а в инспекторе будет отображаться то-что мы написали в скобках Name.

> ==TextArea(1,5)== – 1,5 – Максимальное и минимальное кол-во строк у поля с типом String.

> ==Delayed== – К примеру у нас есть скрипт, который обновляет позицию объекта прямо из инспектора без плей мода, без этого атрибута у нас позиция будет обновляться постоянно, а с ним только после нажатия клавиши Enter. Применяется к каждому полю.

> ==Range(0f,100f)== – Позволит задать границу для полей в инспекторе, которая будет варьироваться от левого, до правого значения, а выбор значения происходить через удобный скроллер. После назначения лучше не оставлять на дефолтных значениях, а зайти и покрутить ползунок, бывают проблемы

> ==Min(0)== – Позволит установить минимальное значение для полей в инспекторе, ниже него сделать значение не получиться.

> ==ColorUsage== – Следует применять для полей с типом Color, с помощью него мы сможем отключить альфа канал или включить ==HDR ColorUsage(showAlpha: false, hdr: true)==

> ==GradientUsage(hdr: true, ColorSpace.Linear)== – Работает примерно так-же как и ColorUsage, только для градиентов. Плюс ко всему позволяет выбрать цветовое пространство, Gamma или Linear. Цветовое пространство лучше не трогать, а вот HDR включить можно.

> ==RequireComponent(typeof(Rigidbody))== – Это действие добавит на объект компонент Rigidbody даже если мы не добавили его сами, плюс ко всему не позволит его удалить. Это будет работать только в том случае, если мы имеем дело не с абстракцией, к примеру если мы укажем Collider то программа не поймет, какой именно коллайдер мы хотим добавить. Бокс коллайдер, сферу или что-то другое.

> ==DisallowMultipleComponent== – предотвращает добавление более одного компонента на объект. Речь идет о том, что, к примеру мы сделали скрипт PlayerHealth и у него добавили этот компонент, теперь мы не сможем положить 2 раза этот скрипт на один объект.

> ==SelectionBase== – Позволяет выделить весь префаб целиком при нажатии на какую-то его часть, а если нужно выбрать именно дочерний объект, то просто кликаем второй раз. Применяется к классу.

> ==ExecuteInEditMode== – Позволит вызываться методам Awake, Update, OnGUI, OnRenderObject прямо в редакторе.

> ==ExecuteAlways== – Похож на предыдущий и позволяет выполняться скрипту как во время игры, так и в редакторе, мы можем менять поведение при помощи ==If(Application.isPlaying)==

> ==CreateAssetMenu== – позволяет создавать Скриптейбл обжект в файлах проекта к примеру:
> 
==CreateAssetMenu(menuName = “Path”, filename = “Name”, order = 0)==

[AddComponentMenu] – Позволяет добавить ваш скрипт в меню добавления компонентов и указать в какой папке он будет находиться, также этим атрибутом можно переименовывать компонент, не изменяя имя класса. Пример:

[AddComponentMenu(“Folder/Folder/NewName”)]

Короче, когда мы нажимаем кнопочку AddComponent, там есть папки, вот мы можем создать эти папки и поместить наш компонент в них, поскольку придется искать папку то все равно проще ввести имя компонента и не париться.

[ContextMenu(nameof(LogMessage))] – Позволит вызвать нужный метод прямо из инспектора в нужное время. Нажав на 3 точки справа от скрипта в котором мы применили этот атрибут.

[MenuItem(“MenuName, PanelName,  FuncName, &#w”)] – Создаст дополнительное меню в верхней панели. Вводиться перед методом.  &#w – Позволяет указать клавишу, при нажатии на которую это будет срабатывать.

[HelpURL(“You_URL”)] – Позволяет указать ссылку, а в инспекторе перед скриптом появиться вопросик, при нажатии на который пользователя перебросит на ваш сайт с документацией или на что вы там дали ссылку.

[InitializeOnLoad] – Позволяет вызвать статический конструктор при запуске Юнити или рекомпиляции, не знаю, что это, может быть потом разберу

[DidReloadSctipts] – Позволяет вызвать статические методы после рекомпиляции, пишется перед методом, а в аргументы можно написать очередь вызова к примеру:

 [DidReloadSctipts(1)] будет вызываться первым.

[PostProcessBuild(2)] – Позволяет сделать что-то после сборки билда в Юнити.

[RuntimeInitializeOnLoadMethod] – Используется со статическим методом, а в аргументы можно передать то, когда он должен быть вызван.

[Conditional] – Позволит заменить код с #if Debug #endif На более простой и короткий [Conditional”Debug”]

[DeScriptExecutionOrder(-99)] – Позволит выбрать порядок выбора скриптом, вспоминаю курс по архитектуре и понимаю что это далеко не лучший выход фиксить проблемы не найденного скрипта таким образом. Да и делать это гораздо проще через графическую оболочку. Так-как там видны вообще все скрипты и порядок их вызова. А попасть в графический вид можно через Edit – Project Settings – Script Execution Order. И вообще надо почитать про Zenject.